#include <EEPROM.h>
#include <Arduino.h>
// für esp_stack_ptr_is_sane
#include <esp_panic.h>
#include <FS.h>
#include <SPIFFS.h>

#include "utils.h"
#include "config.h"
#include "utils_esp32.h"

#define TAG "utils_esp32"

/*
 * stack max used:
#warning FIXME
DEBUGF("TCPClient::readSelect() watermark: %d", uxTaskGetStackHighWaterMark(NULL));
*/

// https://github.com/espressif/esp-idf/blob/23b6d40c537bec674537d52fdea34857a4892dc9/components/esp32/panic.c
void putBacktraceEntryESP32(uint32_t pc, uint32_t sp) {
	if (pc & 0x80000000) {
		pc = (pc & 0x3fffffff) | 0x40000000;
	}
	Serial.printf("%#x:%#x ", pc, sp);
}

/**
 * kopiert von panic.c doBacktrace() - die funktion ist nicht public
 */
void utils::dumpBacktrace() {
	// backtrace:
	register uint32_t curr_sp asm ("sp");
	register uint32_t curr_pc asm ("a0");
	register uint32_t curr_a1 asm ("a1");
	uint32_t sp=curr_sp;
	uint32_t pc=curr_pc;

	Serial.println("for ESP Exception Decoder");
	Serial.print("Backtrace: ");
	// Serial.printf("%#x:%#x %#x issane:%d\n", sp, pc, curr_a1, esp_stack_ptr_is_sane(sp));
	if(!esp_stack_ptr_is_sane(sp)) {
		Serial.printf("invalid stack pointer\n");
		return;
	}
	putBacktraceEntryESP32(pc-3, *((uint32_t *) sp));
	int i=0;
	while (i++ < 100) {
		uint32_t psp = sp;
		if (!esp_stack_ptr_is_sane(sp) || i++ > 100) {
			break;
		}
		sp = *((uint32_t *) (sp - 0x10 + 4));
		// putEntry(pc - 3, sp); // stack frame addresses are return addresses, so subtract 3 to get the CALL address
		putBacktraceEntryESP32(pc-3, sp);
		pc = *((uint32_t *) (psp - 0x10));
		if (pc < 0x40000000) {
			break;
		}
	}
	Serial.println();
}

void printDirectory()
{
	File root = SPIFFS.open("/");
	int levels=0;
	if(!root) {
		NOTICEF("failed to open directory, trying SPIFFS.begin()...");
		if (!SPIFFS.begin()) {
			ERRORF("SPIFFS Mount Failed");
			return;
		}
		DEBUGF("OK: mounting filesystem done");
		root = SPIFFS.open("/");
		if(!root) {
			ERRORF("Error: failed to open directory");
			return;
		}
	}
	if (!root.isDirectory()) {  // kein Verzeichnis, sondern Datei
		ERRORF("Error: / not a directory");
		return;
	}

	File file = root.openNextFile();
	// in einer Schleife durch die Liste aller vorhandenen
	// Einträge gehen
	while (file) {
		if (file.isDirectory()) {
			DEBUGF("  DIR : %s", file.name());
			// ist der Eintrag ein Verz., dann dessen Inhalt rekursiv
			// anzeigen, wenn maximale Tiefe noch nicht erreicht ist
			if (levels) {
				// listDir(fs, file.name(), levels-1);
			}
		} else {
			DEBUGF("  FILE: %s (%dB)", file.name(), file.size());
		}
		file = root.openNextFile();
	}
}

std::string readFile(std::string filename)
{
	if(filename == "protocol.dat") {
		// !!! this file is generated by make protocol.h in the bluetoothserver directory !!!
		#include "protocol.h"
		return protocol_dat;
#ifdef lok_name
	} else if(filename == "conf/lokdef.csv") {
		return "3,  F_DEFAULT," lok_name "," LOK_IMAGE ",   9,"
#ifdef HAVE_SOUND
		"sPfeife"
#endif
		",,"
#ifdef PUTZLOK
		"mPutzmotor"
#elif defined HAVE_SOUND
    "sSound ein/aus=1"
#endif
		",,,,,"
		",mMotor Boost\n";
#endif
	} else if(filename == "conf/decoder_esp32.csv") {
		return
#ifdef HAVE_SOUND
		"266, sound volume,\n"
#endif
		"500, battery level,\n"
		"510, wifi AP switch\n";
	} else {
		if(filename.at(0) != '/') {
			filename="/" + filename;
		}
    if(!SPIFFS.exists(filename.c_str())) {
      ERRORF("file %s doesn't exist", filename.c_str());
      return "";
    }
		File f = SPIFFS.open(filename.c_str(), "r");
		size_t size=f.size();
		DEBUGF("file:%s size:%d", filename.c_str(), size);
		if(size < 10000) {
			std::string ret;
			ret.resize(size);
			// wir schreiben direkt in den string buffer!
			int dataRead=f.read((uint8_t *) &ret[0], size);
			if(dataRead != size) {
				ERRORF("error reading %s", filename.c_str());
				return "";
			}
			return ret;
		}
	}
	abort();
}


bool eeprom_started=false;

uint8_t readEEPROM(int addr) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  return EEPROM.read(addr);
}

void writeEEPROM(int addr1, uint8_t data1, int addr2, uint8_t data2) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  uint8_t existing_data1=EEPROM.read(addr1);
  uint8_t existing_data2=-1;
  if(addr2 >= 0) {
    existing_data2=EEPROM.read(addr2);
  } else {
    existing_data2=data2;
  }
  if(existing_data1 != data1 || existing_data2 != data2) {
    printf("EEPROM.write [%d]:%d (=%d) [%d]:%d (=%d) ******************************\n", addr1, data1, existing_data1, addr2, data2, existing_data2);
    EEPROM.write(addr1, data1);
    if(addr2 >= 0)
      EEPROM.write(addr2, data2);
    EEPROM.commit();
    printf("EEPROM.write verify: [%d]=%d\n", addr1, readEEPROM(addr1));
    if(addr2 >= 0)
      printf("EEPROM.write verify: [%d]=%d\n", addr2, readEEPROM(addr2));
  }
}

/**
 * memmem für ESP32
 * Tests:
Serial.printf("1.: %p\n", memmem("abcdefghi", 9, "abc", 3) );
Serial.printf("2.: %p\n", memmem("abcdefghi", 9, "ghi", 3) );
Serial.printf("3.: %p\n", memmem("abcdefghi", 9, "dghi", 3) );
Serial.printf("4.: %p\n", memmem("abcdef", 4, "abcd", 4) );
 */
void *memmem(const void *haystack, size_t haystacklen,
             const void *needle, size_t needlelen) {
	const char *h=(const char *) haystack;
	const char *n=(const char *) needle;
	if(needlelen > haystacklen) {
		return NULL;
	}
	for(int i=0; i < haystacklen-needlelen+1; i++) { // string ist 16 lang, 2 ist needlelen => +1 damit [14] auch noch gecheckt wird
		for(int j=0; j < needlelen; j++) {
			if(h[i+j] != n[j]) {
        // printf("[%d]=%c != [%d]=%c, ",i+j, h[i+j], j, n[j]);
				goto not_found;
			}
		}
    // DEBUGF("memmem found @%p", &haystack+i);
		return &haystack+i;
		not_found: {}
		// DEBUGF("memmem not found @%d haystack:[%.*s] needle:[%.*s]",i,haystacklen, (const char*) haystack, needlelen, (const char*) needle);
	}
	return NULL;
}

#ifdef OTA_UPDATE
// https://lastminuteengineers.com/esp32-ota-updates-arduino-ide/
#include <ArduinoOTA.h>
#include <ESPmDNS.h>

#endif
void initOTA(void (*onStartCallback)() )
{
#ifdef OTA_UPDATE
  // Port defaults to 3232
  // ArduinoOTA.setPort(3232);

  // Hostname defaults to esp3232-[MAC]
  // ArduinoOTA.setHostname("myesp32");

  // No authentication by default
  // ArduinoOTA.setPassword("admin");

  // Password can be set with it's md5 value as well
  // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3
  // ArduinoOTA.setPasswordHash("21232f297a57a5a743894a0e4a801fc3");

  NOTICEF("Setting up ArduinoOTA");
  ArduinoOTA
    .onStart([onStartCallback]() {
      const char *type="unknown";
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      NOTICEF("Start updating %s", type);
      onStartCallback();
    })
    .onEnd([]() {
      NOTICEF("Update done");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      DEBUGF("Progress: %u%%", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      const char *e="unknown";
      if (error == OTA_AUTH_ERROR) e="Auth Failed";
      else if (error == OTA_BEGIN_ERROR) e="Begin Failed";
      else if (error == OTA_CONNECT_ERROR) e="Connect Failed";
      else if (error == OTA_RECEIVE_ERROR) e="Receive Failed";
      else if (error == OTA_END_ERROR) e="End Failed";
      ERRORF("Error[%u]: %s", error, e);
    });

  // ArduinoOTA.begin startet sonst mdns mit default hostname
  // ArduinoOTA.setHostname(lok_name);
  ArduinoOTA.setMdnsEnabled(false);
  ArduinoOTA.begin();
  MDNS.enableArduino(3232, "");
#endif
}
