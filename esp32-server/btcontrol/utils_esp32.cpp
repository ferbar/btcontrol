#include <EEPROM.h>
#include <Arduino.h>
// f√ºr esp_stack_ptr_is_sane
#include <esp_panic.h>
#include "utils.h"
#include "config.h"
#include "utils_esp32.h"

/*
 * stack max used:
#warning FIXME
DEBUGF("TCPClient::readSelect() watermark: %d", uxTaskGetStackHighWaterMark(NULL));
*/

// https://github.com/espressif/esp-idf/blob/23b6d40c537bec674537d52fdea34857a4892dc9/components/esp32/panic.c
void putBacktraceEntryESP32(uint32_t pc, uint32_t sp) {
	if (pc & 0x80000000) {
		pc = (pc & 0x3fffffff) | 0x40000000;
	}
	Serial.printf("%#x:%#x ", pc, sp);
}

/**
 * kopiert von panic.c doBacktrace() - die funktion ist nicht public
 */
void utils::dumpBacktrace() {
	// backtrace:
	register uint32_t curr_sp asm ("sp");
	register uint32_t curr_pc asm ("a0");
	register uint32_t curr_a1 asm ("a1");
	uint32_t sp=curr_sp;
	uint32_t pc=curr_pc;

	Serial.println("for ESP Exception Decoder");
	Serial.print("Backtrace: ");
	// Serial.printf("%#x:%#x %#x issane:%d\n", sp, pc, curr_a1, esp_stack_ptr_is_sane(sp));
	if(!esp_stack_ptr_is_sane(sp)) {
		Serial.printf("invalid stack pointer\n");
		return;
	}
	putBacktraceEntryESP32(pc-3, *((uint32_t *) sp));
	int i=0;
	while (i++ < 100) {
		uint32_t psp = sp;
		if (!esp_stack_ptr_is_sane(sp) || i++ > 100) {
			break;
		}
		sp = *((uint32_t *) (sp - 0x10 + 4));
		// putEntry(pc - 3, sp); // stack frame addresses are return addresses, so subtract 3 to get the CALL address
		putBacktraceEntryESP32(pc-3, sp);
		pc = *((uint32_t *) (psp - 0x10));
		if (pc < 0x40000000) {
			break;
		}
	}
	Serial.println();
}

std::string readFile(std::string filename)
{
	if(filename == "protocol.dat") {
		// !!! this file is generated by make protocol.h in the bluetoothserver directory !!!
		#include "protocol.h"
		return protocol_dat;
#ifdef lok_name
	} else if(filename == "conf/lokdef.csv") {
		return "3,  F_DEFAULT," lok_name ",                    ,   9,sPfeife,,,,,,,,mMotor Boost\n";
#endif
	}
	abort();
}


bool eeprom_started=false;

uint8_t readEEPROM(int addr) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  return EEPROM.read(addr);
}

void writeEEPROM(int addr1, uint8_t data1, int addr2, uint8_t data2) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  uint8_t existing_data1=EEPROM.read(addr1);
  uint8_t existing_data2;
  if(addr2 >= 0) {
    existing_data2=EEPROM.read(addr2);
  } else {
    existing_data2=data2;
  }
  if(existing_data1 != data1 || existing_data2 != data2) {
    printf("EEPROM.write %d:%d (=%d) %d:%d (=%d) ******************************\n", addr1, data1, existing_data1, addr2, data2, existing_data2);
    EEPROM.write(addr1, data1);
    if(addr2 >= 0)
      EEPROM.write(addr2, data2);
    EEPROM.commit();
  }
}

