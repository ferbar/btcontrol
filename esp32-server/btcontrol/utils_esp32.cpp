#include <EEPROM.h>
#include <Arduino.h>
// für esp_stack_ptr_is_sane
#include <esp_panic.h>
#include <FS.h>
#include <SPIFFS.h>

#include "utils.h"
#include "config.h"
#include "utils_esp32.h"

#define TAG "utils_esp32"

/*
 * stack max used:
#warning FIXME
DEBUGF("TCPClient::readSelect() watermark: %d", uxTaskGetStackHighWaterMark(NULL));
*/

// https://github.com/espressif/esp-idf/blob/23b6d40c537bec674537d52fdea34857a4892dc9/components/esp32/panic.c
void putBacktraceEntryESP32(uint32_t pc, uint32_t sp) {
	if (pc & 0x80000000) {
		pc = (pc & 0x3fffffff) | 0x40000000;
	}
	Serial.printf("%#x:%#x ", pc, sp);
}

/**
 * kopiert von panic.c doBacktrace() - die funktion ist nicht public
 */
void utils::dumpBacktrace() {
	// backtrace:
	register uint32_t curr_sp asm ("sp");
	register uint32_t curr_pc asm ("a0");
	register uint32_t curr_a1 asm ("a1");
	uint32_t sp=curr_sp;
	uint32_t pc=curr_pc;

	Serial.println("for ESP Exception Decoder");
	Serial.print("Backtrace: ");
	// Serial.printf("%#x:%#x %#x issane:%d\n", sp, pc, curr_a1, esp_stack_ptr_is_sane(sp));
	if(!esp_stack_ptr_is_sane(sp)) {
		Serial.printf("invalid stack pointer\n");
		return;
	}
	putBacktraceEntryESP32(pc-3, *((uint32_t *) sp));
	int i=0;
	while (i++ < 100) {
		uint32_t psp = sp;
		if (!esp_stack_ptr_is_sane(sp) || i++ > 100) {
			break;
		}
		sp = *((uint32_t *) (sp - 0x10 + 4));
		// putEntry(pc - 3, sp); // stack frame addresses are return addresses, so subtract 3 to get the CALL address
		putBacktraceEntryESP32(pc-3, sp);
		pc = *((uint32_t *) (psp - 0x10));
		if (pc < 0x40000000) {
			break;
		}
	}
	Serial.println();
}

void printDirectory()
{
	File root = SPIFFS.open("/");
	int levels=0;
	if(!root) {
		ERRORF("- failed to open directory");
		if (!SPIFFS.begin()) {
			ERRORF("SPIFFS Mount Failed");
			return;
		}
		DEBUGF("mounting filesystem done");
		root = SPIFFS.open("/");
		if(!root) {
			ERRORF("- failed to open directory");
			return;
		}
	}
	if (!root.isDirectory()) {  // kein Verzeichnis, sondern Datei
		ERRORF("− not a directory");
		return;
	}

	File file = root.openNextFile();
	// in einer Schleife durch die Liste aller vorhandenen
	// Einträge gehen
	while (file) {
		if (file.isDirectory()) {
			DEBUGF("  DIR : %s", file.name());
			// ist der Eintrag ein Verz., dann dessen Inhalt rekursiv
			// anzeigen, wenn maximale Tiefe noch nicht erreicht ist
			if (levels) {
				// listDir(fs, file.name(), levels-1);
			}
		} else {
			DEBUGF("  FILE: %s (%dB)", file.name(), file.size());
		}
		file = root.openNextFile();
	}
}

std::string readFile(std::string filename)
{
	if(filename == "protocol.dat") {
		// !!! this file is generated by make protocol.h in the bluetoothserver directory !!!
		#include "protocol.h"
		return protocol_dat;
#ifdef lok_name
	} else if(filename == "conf/lokdef.csv") {
		return "3,  F_DEFAULT," lok_name "," LOK_IMAGE ",   9,"
#ifdef HAVE_SOUND
		"sPfeife"
#endif
		",,"
#ifdef PUTZLOK
		"mPutzmotor"
#endif
		",,,,,,mMotor Boost\n";
#endif
	} else if(filename == "conf/decoder_esp32.csv") {
		return
#ifdef HAVE_SOUND
		"266, sound volume,\n"
#endif
		"500, battery level,\n"
		"510, wifi AP switch\n";
	} else {
		if(filename.at(0) != '/') {
			filename="/" + filename;
		}
		File f = SPIFFS.open(filename.c_str(), "r");
		size_t size=f.size();
		DEBUGF("file:%s size:%d", filename.c_str(), size);
		if(size < 10000) {
			std::string ret;
			ret.resize(size);
			// wir schreiben direkt in den string buffer!
			int dataRead=f.read((uint8_t *) &ret[0], size);
			if(dataRead != size) {
				ERRORF("error reading %s", filename.c_str());
				return "";
			}
			return ret;
		}
	}
	abort();
}


bool eeprom_started=false;

uint8_t readEEPROM(int addr) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  return EEPROM.read(addr);
}

void writeEEPROM(int addr1, uint8_t data1, int addr2, uint8_t data2) {
  if(!eeprom_started) {
    EEPROM.begin(EEPROM_VALUES);
  }
  uint8_t existing_data1=EEPROM.read(addr1);
  uint8_t existing_data2;
  if(addr2 >= 0) {
    existing_data2=EEPROM.read(addr2);
  } else {
    existing_data2=data2;
  }
  if(existing_data1 != data1 || existing_data2 != data2) {
    printf("EEPROM.write %d:%d (=%d) %d:%d (=%d) ******************************\n", addr1, data1, existing_data1, addr2, data2, existing_data2);
    EEPROM.write(addr1, data1);
    if(addr2 >= 0)
      EEPROM.write(addr2, data2);
    EEPROM.commit();
  }
}

/**
 * memmem für ESP32
 * Tests:
Serial.printf("1.: %p\n", memmem("abcdefghi", 10, "abc", 3) );
Serial.printf("2.: %p\n", memmem("abcdefghi", 10, "ghi", 3) );
Serial.printf("3.: %p\n", memmem("abcdefghi", 10, "dghi", 3) );
Serial.printf("4.: %p\n", memmem("abcdef", 3, "abcd", 4) );
 */
void *memmem(const void *haystack, size_t haystacklen,
             const void *needle, size_t needlelen) {
	const char *h=(const char *) haystack;
	const char *n=(const char *) needle;
	if(needlelen > haystacklen) {
		return NULL;
	}
	for(int i=0; i < haystacklen-needlelen; i++) {
		for(int j=0; j < needlelen; j++) {
			if(h[i+j] != n[j]) {
				goto not_found;
			}
		}
		return &haystack+i;
		not_found: {}
		// printf("test %d\n",i);
	}
	return NULL;
}
